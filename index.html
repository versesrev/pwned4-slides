<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CTF+Maths=SageMath</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
        <style>
            .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5 {
                text-transform: none;
            }
            .reveal .footer {
                position: absolute;
                bottom: 1em;
                left: 1em;
                font-size: 0.5em;
            }
            .reveal pre code {
                max-height: 1000px;
            }
        </style>
	</head>
	<body>
		<div class="reveal">
            <div class='footer'>
                Slides available at versesrev.github.io/pwned4-slides
            </div>
			<div class="slides">
				<section data-markdown data-separator-vertical="^\n--\n$">
                    <script type="text/template">
                        # CTF + Maths = SageMath
                        
                        esrever
                        
                        ---
                        
                        ## I will talk about
                        * some SageMath code
                        * some Maths behind the code
                        * some numbers output by the code
                        
                        --
                        
                        ## I will NOT talk about
                        * [Alice nor Bob](https://en.wikipedia.org/wiki/Alice_and_Bob)
                        * [base64](https://twitter.com/LetsDefendIO/status/1583471423498035200/photo/1)
                        * [cryptocurrency](https://www.cryptoisnotcryptocurrency.com/)
                        
                    </script>
                </section>
                
                <section data-markdown data-separator-vertical="^\n--\n$">
                    <script type="text/template">
                        ## Modular arithmetic
                        
                        --
                        
                        * _In programming_: modulus operation `%`.
                        * _In mathematics_: "reduced" numbers that can do `+, -, *, **`. Just like intergers, rational numbers and real numbers.
                        
                        --
                        
                        ### Example ([SageMathCell](https://sagecell.sagemath.org/?z=eJxLSU1TKEotyNEo1rRSKCjKzCvRSFOys7NTqC6ujcmrLk5MT41PLUsEydcqafJy8XKBVStpGBkoaCuYGGgqqCqYGoNkEOK6WMSBwloKJmiCJgpaWgrGaIKGCvoKZlAxACW4JYU=&lang=sage&interacts=eJyLjgUAARUAuQ==))
                        ```python
                        >>> (20 + 40) % 53
                        7
                        >>> (20 - 40) % 53
                        33
                        >>> 20 * 4 % 53
                        27
                        >>> 4 ** 3 % 53
                        11
                        >>> 1 / 6 % 53
                        9
                        >>> 
                        ```
                        
                        ---
                        
                        ## Carmichael lambda
                        
                        --
                        
                        * The sequence $\\{a^i \pmod{n} \\}$ has repeated terms.
                        * If $a$ coprime to $n$, the sequence contains 1 and becomes a cycle.
                        * Carmichael function $\lambda(n)$: smallest period for all $a$ coprime to $n$.
                        
                        --
                        
                        ### [Example](https://sagecell.sagemath.org/?z=eJxlj01qwzAQhfcG3-HhlSRMsJP-0IB9kbaYiS07Av0YybSLNCfrHXqmSk7bBDobSfPmffM0yBFezpoFvsfslV3YWLRti1M4v9hToEl28o2iXkK7nnRoLgfj-MCk3WG983PB8yzPLBrcC7GDwKMQ2zxb2cXz7N7Z025bQpW3OsfoPBSUhSc7SVZX_DWRvj67hNK9YXciGqLzQURHzX-RaaL4e638EqlZwvJ_Ql1V4lbMs9E7g_S9DXm1HDdGhR7KzM4v6Mkb1R9J6k6TOQwECpF9Xc0ulBSeruEt3-cZYqkRUz8wStvQNKh_-qkoBBlX1KmfwlFKHa1p9hvbdXQX&lang=sage&interacts=eJyLjgUAARUAuQ==)
                        ```python
                        >>> n = 5**3 * 7**2
                        >>> [pow(932, i, n) for i in range(10)]
                        [1, 932, 4999, 4068, 1, 932, 4999, 4068, 1, 932]
                        >>> λ_n = lcm(4*5**2, 6*7**1); λ_n
                        2100
                        >>> pow(9, λ_n, n)
                        1
                        >>> pow(9, 100*λ_n, n)
                        1
                        >>> 
                        ```
                        ```python
                        >>> from sage.arith.misc import carmichael_lambda as λ
                        >>> λ(n)
                        2100
                        >>> for a in range(n):
                        ...     if gcd(a, n) == 1:
                        ...         assert 1 == pow(a, λ(n), n)
                        ... 
                        >>> 
                        ```
                        
                        --
                        
                        * Knowing $\lambda(n)$ is hard (without factorizing $n$).
                        ```python
                        >>> p = random_prime(2**1024)
                        >>> q = random_prime(2**1024)
                        >>> n = p * q
                        >>> λ_n = lcm(p - 1, q - 1)
                        >>> assert 1 == pow(2, λ_n, n)
                        >>> # λ(n)  # This will take forever
                        >>> 
                        ```
                        
                        ---
                        
                        ## Textbook RSA
                        
                        --
                        
                        * Encryption: $c \equiv m ^ e \pmod{n}$
                        * Decryption: $m \equiv c ^ d \pmod{n}$
                        * $c ^ d \equiv m ^ {\textcolor{blue}{e \times d}} \equiv m ^ {\textcolor{blue}{k \times \lambda(n) + 1}} \equiv m \pmod{n}$
                        
                        --
                        
                        ### [Example](https://sagecell.sagemath.org/?z=eJx9kE1qwzAQRvcG3-GDEuqUkMaxS6DgE3RTaPdBkSeWqP6QZEzOljvkTJUSL5JNNlrMN_PejI7eagQ20Jp5GcVay8AhtbM-gjOvJReM1F4xfegZWMDlXBZlYdCh3tR4S-8OeMH3eFCSlwXl4KHSp0q7-Why7Ye4p1gWLARKghpdB0qQHosErswys8nwNDIbXfyEs1Pl4gq0Qu7o6S7nc85T3t_yGd5uMz01VwlYtdvlFa4v57xh0-yS9qrMe30ZO0kzgEGPKkqnCDKAjB0HgWgzxZ9cvB1T4z0tvYDOX_FUNoc0KvJ7J2S2zYfm9k1W_woWXwMmcULqwGT9X3j03I8_Ef4DDfyGJg==&lang=sage&interacts=eJyLjgUAARUAuQ==)
                        ```python
                        >>> n = 101 * 107  # Public
                        >>> e = 17  # Public
                        >>> d = 4053  # Secret
                        >>> assert 1 == e * d % λ(n)
                        >>> 
                        >>> enc = lambda pt: pow(pt, e, n)
                        >>> dec = lambda ct: pow(ct, d, n)
                        >>> assert 42 == dec(enc(42))
                        >>> 
                        ```
                        ```python
                        >>> mλ = 1337 * λ(n)  # Knowing a multiple is enough to decrypt
                        >>> d = 1 / e % mλ
                        >>> assert 42 == dec(enc(42))
                        ```
                        ```python
                        >>> assert euler_phi(n) % λ(n) == 0  # That's why phi works
                        >>> d = 1 / e % euler_phi(n)
                        >>> assert 42 == dec(enc(42))
                        >>> 
                        ```
                        
                        ---
                        
                        ## Time-lock puzzle
                        
                        --
                        
                        * Squaring $t$ times:
                          `\[ a ^ {2 ^ t} \pmod{n} \]`
                        * LCS35: $|t|=47\text{ bits}, |n|=2048\text{ bits}$.
                        
                        --
                        
                        ### [Example](https://sagecell.sagemath.org/?z=eJyVUN1qgzAUvhd8hw93Y4KUagfdCi3sHXY5kFSjhsVEEm0vuj5Z38FnWmKxrOwHlouccL6f852UvILhnYwt2aAzQvVxFe12O5zs-U2dLKt5zg_M4QmkLpi022uJCT5QS72f3uQcJajkYJvtqxk4CYMwqIxu4Q0WzIi-WbTCFhBtp02PgplWFA3jMpes3ZcMzGK8eFnpEikmDjxmCfoEimzCAO4Y3g9GodNHj2SUTqCXMGyxCgPlSrpMQd29DoNprehmlXp2RL71s1_66ZLSpz-w5xm7Rn5X-ihUnY-XOXfiFvo5uy_ZRHKMeYnxkvsFnF7dBt6bzlO9LP-a657mfuZx_R9aulqt6cQFHvCCdpC96CSHrpwFhAVXeqibiHwCnyypyw==&lang=sage&interacts=eJyLjgUAARUAuQ==)
                        ```python
                        >>> def naive(a, t, n):
                        ...     return pow(a, 2**t, n)
                        ... 
                        >>> a = 3
                        >>> n = 101 * 107
                        >>> naive(a, 1, n)
                        9
                        >>> naive(a, 2, n)
                        81
                        >>> 
                        ```
                        ```python
                        >>> time naive(a, 10**8, n)
                        CPU times: user 1.56 s, sys: 15 ms, total: 1.58 s
                        Wall time: 1.59 s
                        5121
                        >>> time naive(a, 10**9, n)
                        CPU times: user 15.5 s, sys: 109 ms, total: 15.6 s
                        Wall time: 15.7 s
                        1384
                        >>> 
                        ```
                        
                        --
                        
                        ```python
                        >>> def knowing_λ(a, t, n, λ):
                        ...     return pow(a, pow(2, t, λ), n)
                        ... 
                        >>> λ_n = λ(n)
                        >>> time knowing_λ(a, 10**9, n, λ_n)
                        CPU times: user 0 ns, sys: 0 ns, total: 0 ns
                        Wall time: 179 µs
                        1384
                        >>> time knowing_λ(a, 2**47, n, λ_n)
                        CPU times: user 0 ns, sys: 0 ns, total: 0 ns
                        Wall time: 563 µs
                        4422
                        >>> knowing_λ(a, 2**47, n, 1337*λ_n)  # A multiple of λ is enough
                        4422
                        ```
                        
                        ---
                        
                        ## (Weak) time-lock puzzle
                        * [Google CTF 2022 cycling](https://github.com/google/google-ctf/tree/master/2022/quals/crypto-cycling):
                          `\[ \lambda(\lambda(n)) \mid 2^{1025} - 2 \]`
                        In other words, for $t = 2^{1025} - 2$ and most $a, b$,
                          `\[ a ^ {b ^ t} \equiv a \pmod{n}\ . \]`
                        
                        --
                        
                        # Spoiler alert!
                        
                        --
                        
                        * We want to get a multiple of $\textcolor{red}{\lambda(n)}$.
                        * A prime factor of $\textcolor{red}{\lambda(n)}$ is either <!-- .element: class="fragment" data-fragment-index="2" -->
                          1. a prime factor of $\textcolor{blue}{\lambda(\lambda(n))}$ or
                          1. a divisor of $\textcolor{blue}{\lambda(\lambda(n))}$ plus one.  
                          Example: $\lambda(\textcolor{red}{5^3 \cdot 7^1}) = \textcolor{blue}{\text{lcm}(4 \cdot 5^2, 6 \cdot 7^0)}$.
                        * $\textcolor{blue}{2^{1025} - 2}$ is a special number: we know the factorization.

                        --
                        
                        ```python
                        λλn = 2**1025 - 2
                        
                        # Case 1
                        λn_potential_factors = set(factor(λλn))  # TODO: help Sage factor
                        
                        # Case 2
                        for d in divisor(λλn):  # TODO: help Sage find divisors
                            if is_prime(d + 1):
                                λn_potential_factors.add(d + 1)
                        
                        # Get multiple of λ(n)
                        mλn = prod(p ** e for p in λn_potential_factors)  # TODO: choose e
                        
                        # Win!
                        knowing_λ(a, t, n, mλn)
                        ```
                        
                        --
                        
                        ### TODO: Factorize $2^{1025} - 2$
                        * $2^{1024} - 1$ is a Mersenne number.
                        * http://factordb.com/
                          ![](./factordb.png)
                        
                        --
                        
                        ### TODO: Find all divisors of $2^{1025} - 2$
                        * It has 17 prime factors. All have multiplicity 1.
                        ```python
                        # From the itertools documentation/example
                        from itertools.chain import from_iterable
                        from itertools import combinations
                        def powerset(iterable):
                              """powerset([1,2,3]) --> () (1,) (2,) (3,)
                                                  (1,2) (1,3) (2,3) (1,2,3)"""
                              s = list(iterable)
                              return from_iterable(
                                  combinations(s, r) for r in range(len(s)+1)
                              )
                        for primes in powerset(factors):
                              d = prod(primes)
                              # Do something with d
                        ```
                        
                        --
                        
                        ### TODO: Choose multiplicity for each potential factor
                        * $e = 1$ works for this particular challenge.
                        * $e = \lceil \log{n} / \log{p} \rceil$ should work.
                        
                        --
                        
                        ### Putting together
                        ```python
                        λλn = 2**1025 - 2
                        factors = [...]
                        assert λλn == prod(factors)
                        
                        # Case 1
                        λn_potential_factors = set(factors)
                        
                        # Case 2
                        for primes in powerset(factors):
                            d = prod(primes)
                            if is_prime(d + 1):
                                λn_potential_factors.add(d + 1)
                        
                        # Get multiple of λ(n)
                        mλn = prod(λn_potential_factors)
                        
                        # Win!
                        knowing_λ(a, t, n, mλn)
                        ```
                        
                    </script>
                </section>
                
                <section data-markdown data-separator-vertical="^\n--\n$">
                    <script type="text/template">
                        # Thank you!
                    </script>
                </section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
        <script src="plugin/math/math.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
                slideNumber: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});
		</script>
	</body>
</html>
